# My initial solution is convert to string and return count 1, but I think this shall not be the optimized answer here.
# Second solution is always calculate if the last bits is 1 till num == 0. since the bits is continue shrink, we can think this will 
# provide good answer here.
# if we can't use any operation expect >> or <<, then we only have solution #3. >> means divided by 2 and should provide the solution
# 移位运算符不是 a >> 1 而是 a >> = 1:

// covert to string and count: 
class Solution:
    """
    @param: num: An integer
    @return: An integer
    """
    def countOnes(self, num):
        # write your code here
        if num == None:
            return num
        if num < 0:
            num = 2**32 + num
        return str(bin(num)).count('1')

// always calculate if the last bits is 1 till num == 0:
def countOnes(self, num):
        # write your code here
        count = 0
        if num < 0:
            num += 2 ** 32
        while num != 0:
            if num % 2 == 1:
                count += 1
            num /= 2
        return count

// divided by 2 fulfilled by right shift one bit, and use & 1 to check if last bits is 0 or 1:
// Not the -1 will alwasy == -1, so you will limited it by 32 bits. 
class Solution:
    """
    @param: num: An integer
    @return: An integer
    """
    def countOnes(self, num):
        # write your code here
        count = 0
        n = 0
        while num != 0 and n < 32:
            if num & 1: # if last bit is 1 then is True, else: False
                count += 1
            #print num
            num >>= 1
            n += 1
        return count
