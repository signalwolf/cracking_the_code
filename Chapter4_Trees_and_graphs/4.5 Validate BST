# 两种方法，如果当前的BST中允许duplicate, 那么就只有一种方法
# 第一种方法就是根据转换来的，inorder traverse的结果如果是increasing list那么就是valid. 只是如果一个点左右两边都是
# 与node.val相同的话，其实应该算not vaild，但是这种方法算不出来
# 第二种方法就是根据定义，我们定义当前的最大和最小，向左走就改变最大，向右走就改变最小。逐层的判断下去直到leaf节点

"""
Definition of TreeNode:
class TreeNode:
    def __init__(self, val):
        self.val = val
        self.left, self.right = None, None
"""

// Solution 2: in order tranverse and then check if it is increasing order nums: 
class Solution:
    """
    @param: root: The root of binary tree.
    @return: True if the binary tree is BST, or false
    """
    def inorder (self, root):
        if root.left == None and root.right == None:
            return [root.val]
        left, right = [], []
        if root.left != None:
            left = self.inorder (root.left)
        if root.right != None:
            right = self.inorder (root.right)
        return left + [root.val] + right
        
    def check (self, nums):
        for i in xrange(len(nums) - 1):
            if nums[i] < nums[i + 1]:
                continue
            else:
                return False
        return True
    
    def isValidBST(self, root):
        # write your code here
        if root is None:
            return True
        # recursion to find the issue:
        # divide and conquer:
        # define: receive a node and goes deeper to its left node, then goes to right node
        # shirnk: a bigger tree can isolate to a smaller tree
        # out: if it is leaf node, return it's value; if not, after left node return, add curr, then right node
        #inorder = []
        inorder = self.inorder (root)
        return self.check(inorder)
        
